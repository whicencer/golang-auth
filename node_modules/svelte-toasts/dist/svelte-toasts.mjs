function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
    let value;
    subscribe(store, _ => value = _)();
    return value;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}

function append(target, node) {
    target.appendChild(node);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, false, false, detail);
    return e;
}

const active_docs = new Set();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = node.ownerDocument;
    active_docs.add(doc);
    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
    if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        active_docs.forEach(doc => {
            const stylesheet = doc.__svelte_stylesheet;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            doc.__svelte_rules = {};
        });
        active_docs.clear();
    });
}

function create_animation(node, from, fn, params) {
    if (!from)
        return noop;
    const to = node.getBoundingClientRect();
    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
        return noop;
    const { delay = 0, duration = 300, easing = identity, 
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay, 
    // @ts-ignore todo:
    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);
    let running = true;
    let started = false;
    let name;
    function start() {
        if (css) {
            name = create_rule(node, 0, 1, duration, delay, easing, css);
        }
        if (!delay) {
            started = true;
        }
    }
    function stop() {
        if (css)
            delete_rule(node, name);
        running = false;
    }
    loop(now => {
        if (!started && now >= start_time) {
            started = true;
        }
        if (started && now >= end) {
            tick(1, 0);
            stop();
        }
        if (!running) {
            return false;
        }
        if (started) {
            const p = now - start_time;
            const t = 0 + 1 * easing(p / duration);
            tick(t, 1 - t);
        }
        return true;
    });
    start();
    tick(0, 1);
    return stop;
}
function fix_position(node) {
    const style = getComputedStyle(node);
    if (style.position !== 'absolute' && style.position !== 'fixed') {
        const { width, height } = style;
        const a = node.getBoundingClientRect();
        node.style.position = 'absolute';
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a);
    }
}
function add_transform(node, a) {
    const b = node.getBoundingClientRect();
    if (a.left !== b.left || a.top !== b.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
    }
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    let config = fn(node, params);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            delete_rule(node);
            if (is_function(config)) {
                config = config();
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}
function create_out_transition(node, fn, params) {
    let config = fn(node, params);
    let running = true;
    let animation_name;
    const group = outros;
    group.r += 1;
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        add_render_callback(() => dispatch(node, false, 'start'));
        loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(0, 1);
                    dispatch(node, false, 'end');
                    if (!--group.r) {
                        // this will result in `end()` being called,
                        // so we don't need to clean up here
                        run_all(group.c);
                    }
                    return false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(1 - t, t);
                }
            }
            return running;
        });
    }
    if (is_function(config)) {
        wait().then(() => {
            // @ts-ignore
            config = config();
            go();
        });
    }
    else {
        go();
    }
    return {
        end(reset) {
            if (reset && config.tick) {
                config.tick(1, 0);
            }
            if (running) {
                if (animation_name)
                    delete_rule(node, animation_name);
                running = false;
            }
        }
    };
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function fix_and_outro_and_destroy_block(block, lookup) {
    block.f();
    outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

const subscriber_queue = [];
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = [];
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (let i = 0; i < subscribers.length; i += 1) {
                    const s = subscribers[i];
                    s[1]();
                    subscriber_queue.push(s, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            const index = subscribers.indexOf(subscriber);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
            if (subscribers.length === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}

function notificationsStore(initialValue = []) {
  const store = writable(initialValue);
  const { set, update, subscribe } = store;
  let defaultOptions = {
    duration: 3000,
    placement: 'bottom-right',
    type: 'info',
    theme: 'dark',
  };
  function add(options) {
    const {
      duration = 3000,
      placement = 'bottom-right',
      type = 'info',
      theme = 'dark',
      ...rest
    } = { ...defaultOptions, ...options };

    const uid = Date.now();
    const obj = {
      ...rest,
      uid,
      placement,
      type,
      theme,
      duration,
      remove: () => {
        update((v) => v.filter((i) => i.uid !== uid));
      },
      update: (data) => {
        delete data.uid;
        const index = get_store_value(store)?.findIndex((v) => v?.uid === uid);
        if (index > -1) {
          update((v) => [
            ...v.slice(0, index),
            { ...v[index], ...data },
            ...v.slice(index + 1),
          ]);
        }
      },
    };
    update((v) => [...v, obj]);
    if (duration > 0) {
      setTimeout(() => {
        obj.remove();
        if (typeof obj.onRemove === 'function') obj.onRemove();
      }, duration);
    }
    return obj;
  }

  function getById(uid) {
    return get_store_value(store)?.find((v) => v?.uid === uid);
  }

  function clearAll() {
    set([]);
  }
  function clearLast() {
    update((v) => {
      return v.slice(0, v.length - 1);
    });
  }

  function setDefaults(options) {
    defaultOptions = { ...defaultOptions, ...options };
  }

  return {
    subscribe,
    add,
    success: getHelper('success', add),
    info: getHelper('info', add),
    error: getHelper('error', add),
    warning: getHelper('warning', add),
    clearAll,
    clearLast,
    getById,
    setDefaults,
  };
}
const toasts = notificationsStore([]);

function getHelper(type, add) {
  return function () {
    if (typeof arguments[0] === 'object') {
      const options = arguments[0];
      return add({ ...options, type });
    } else if (
      typeof arguments[0] === 'string' &&
      typeof arguments[1] === 'string'
    ) {
      const options = arguments[2] || {};
      return add({
        ...options,
        type,
        title: arguments[0],
        description: arguments[1],
      });
    } else if (typeof arguments[0] === 'string') {
      const options = arguments[1] || {};
      return add({
        ...options,
        type,
        description: arguments[0],
      });
    }
  };
}

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}
function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
    };
}

function flip(node, animation, params = {}) {
    const style = getComputedStyle(node);
    const transform = style.transform === 'none' ? '' : style.transform;
    const scaleX = animation.from.width / node.clientWidth;
    const scaleY = animation.from.height / node.clientHeight;
    const dx = (animation.from.left - animation.to.left) / scaleX;
    const dy = (animation.from.top - animation.to.top) / scaleY;
    const d = Math.sqrt(dx * dx + dy * dy);
    const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
    return {
        delay,
        duration: is_function(duration) ? duration(d) : duration,
        easing,
        css: (_t, u) => `transform: ${transform} translate(${u * dx}px, ${u * dy}px);`
    };
}

/* src/ToastContainer.svelte generated by Svelte v3.35.0 */

function add_css$2() {
	var style = element("style");
	style.id = "svelte-1rg6zyw-style";
	style.textContent = "ul.svelte-1rg6zyw.svelte-1rg6zyw{list-style:none;margin:0;padding:0}li.svelte-1rg6zyw.svelte-1rg6zyw{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}.toast-container.svelte-1rg6zyw.svelte-1rg6zyw{z-index:9999;position:fixed;padding:4px;box-sizing:border-box;color:#fff;width:max-content;max-width:100%;pointer-events:none}.toast-container.bottom-right.svelte-1rg6zyw.svelte-1rg6zyw{bottom:1em;right:1em}.toast-container.bottom-left.svelte-1rg6zyw.svelte-1rg6zyw{bottom:1em;left:1em}.toast-container.top-left.svelte-1rg6zyw.svelte-1rg6zyw{top:1em;left:1em}.toast-container.top-right.svelte-1rg6zyw.svelte-1rg6zyw{top:1em;right:1em}.toast-container.top-center.svelte-1rg6zyw.svelte-1rg6zyw{top:1em;right:50%;left:50%;transform:translate(-50%, 0)}.toast-container.bottom-center.svelte-1rg6zyw.svelte-1rg6zyw{bottom:1em;right:50%;left:50%;transform:translate(-50%, 0)}.toast-container.center-center.svelte-1rg6zyw.svelte-1rg6zyw{top:50%;right:50%;left:50%;transform:translate(-50%, -50%)}.toast-container.svelte-1rg6zyw>.svelte-1rg6zyw:not(:last-child){margin-bottom:10px}";
	append(document.head, style);
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

const get_default_slot_changes = dirty => ({ data: dirty & /*$toasts*/ 4 });
const get_default_slot_context = ctx => ({ data: /*toast*/ ctx[14] });

// (107:10) {:else}
function create_else_block$2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], get_default_slot_context);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, $toasts*/ 516) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_default_slot_changes, get_default_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (105:10) {#if toast.component}
function create_if_block$2(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*toast*/ ctx[14].component;

	function switch_props(ctx) {
		return { props: { data: /*toast*/ ctx[14] } };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = {};
			if (dirty & /*$toasts*/ 4) switch_instance_changes.data = /*toast*/ ctx[14];

			if (switch_value !== (switch_value = /*toast*/ ctx[14].component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (97:6) {#each $toasts         .filter((n) => n.placement === placement)         .reverse() as toast (toast.uid)}
function create_each_block_1(key_1, ctx) {
	let li;
	let current_block_type_index;
	let if_block;
	let t;
	let li_intro;
	let li_outro;
	let rect;
	let stop_animation = noop;
	let current;
	const if_block_creators = [create_if_block$2, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*toast*/ ctx[14].component) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			if_block.c();
			t = space();
			attr(li, "class", "svelte-1rg6zyw");
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			if_blocks[current_block_type_index].m(li, null);
			append(li, t);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(li, t);
			}
		},
		r() {
			rect = li.getBoundingClientRect();
		},
		f() {
			fix_position(li);
			stop_animation();
			add_transform(li, rect);
		},
		a() {
			stop_animation();
			stop_animation = create_animation(li, rect, flip, {});
		},
		i(local) {
			if (current) return;
			transition_in(if_block);

			add_render_callback(() => {
				if (li_outro) li_outro.end(1);
				if (!li_intro) li_intro = create_in_transition(li, fade, { duration: 500 });
				li_intro.start();
			});

			current = true;
		},
		o(local) {
			transition_out(if_block);
			if (li_intro) li_intro.invalidate();

			li_outro = create_out_transition(li, fly, {
				y: /*flyMap*/ ctx[4][/*toast*/ ctx[14].placement],
				duration: 1000
			});

			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if_blocks[current_block_type_index].d();
			if (detaching && li_outro) li_outro.end();
		}
	};
}

// (94:0) {#each placements as placement}
function create_each_block(ctx) {
	let div;
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t;
	let current;

	function func(...args) {
		return /*func*/ ctx[11](/*placement*/ ctx[1], ...args);
	}

	let each_value_1 = /*$toasts*/ ctx[2].filter(func).reverse();
	const get_key = ctx => /*toast*/ ctx[14].uid;

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
	}

	return {
		c() {
			div = element("div");
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr(ul, "class", "svelte-1rg6zyw");
			attr(div, "class", "toast-container " + /*placement*/ ctx[1] + " svelte-1rg6zyw");
			set_style(div, "width", /*width*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			append(div, t);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*flyMap, $toasts, placements, $$scope*/ 540) {
				each_value_1 = /*$toasts*/ ctx[2].filter(func).reverse();
				group_outros();
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, ul, fix_and_outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
				check_outros();
			}

			if (!current || dirty & /*width*/ 1) {
				set_style(div, "width", /*width*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

function create_fragment$2(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*placements*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*placements, width, $toasts, flyMap, $$scope*/ 541) {
				each_value = /*placements*/ ctx[3];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let $toasts;
	component_subscribe($$self, toasts, $$value => $$invalidate(2, $toasts = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	let { theme = "dark" } = $$props;
	let { placement = "bottom-right" } = $$props;
	let { type = "info" } = $$props;
	let { showProgress = false } = $$props;
	let { duration = 3000 } = $$props;
	let { width = "320px" } = $$props;

	/**
 * Default slot which is Toast component/template which will get toast data
 * @slot {{ data: ToastProps }}
 */
	const placements = [
		"bottom-right",
		"bottom-left",
		"top-right",
		"top-left",
		"top-center",
		"bottom-center",
		"center-center"
	];

	const flyMap = {
		"bottom-right": 400,
		"top-right": -400,
		"bottom-left": 400,
		"top-left": -400,
		"bottom-center": 400,
		"top-center": -400,
		"center-center": -800
	};

	onMount(() => {
		toasts.setDefaults({
			placement,
			showProgress,
			theme,
			duration,
			type
		});
	});

	const func = (placement, n) => n.placement === placement;

	$$self.$$set = $$props => {
		if ("theme" in $$props) $$invalidate(5, theme = $$props.theme);
		if ("placement" in $$props) $$invalidate(1, placement = $$props.placement);
		if ("type" in $$props) $$invalidate(6, type = $$props.type);
		if ("showProgress" in $$props) $$invalidate(7, showProgress = $$props.showProgress);
		if ("duration" in $$props) $$invalidate(8, duration = $$props.duration);
		if ("width" in $$props) $$invalidate(0, width = $$props.width);
		if ("$$scope" in $$props) $$invalidate(9, $$scope = $$props.$$scope);
	};

	return [
		width,
		placement,
		$toasts,
		placements,
		flyMap,
		theme,
		type,
		showProgress,
		duration,
		$$scope,
		slots,
		func
	];
}

class ToastContainer extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1rg6zyw-style")) add_css$2();

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			theme: 5,
			placement: 1,
			type: 6,
			showProgress: 7,
			duration: 8,
			width: 0
		});
	}
}

/* src/BootstrapToast.svelte generated by Svelte v3.35.0 */

function add_css$1() {
	var style = element("style");
	style.id = "svelte-1t011t6-style";
	style.textContent = ".st-toast.svelte-1t011t6.svelte-1t011t6{width:100%;pointer-events:auto;cursor:pointer;z-index:10000;max-width:100%;font-size:0.875rem;pointer-events:auto;background-color:rgba(255, 255, 255, 0.85);background-clip:padding-box;border:1px solid rgba(0, 0, 0, 0.1);box-shadow:0 0.5rem 1rem rgba(0, 0, 0, 0.15);border-radius:0.25rem}.st-toast.success.svelte-1t011t6 .st-toast-icon.svelte-1t011t6{fill:rgb(22, 163, 74);color:#fff}.st-toast.info.svelte-1t011t6 .st-toast-icon.svelte-1t011t6{fill:rgb(2, 132, 199);color:#fff}.st-toast.error.svelte-1t011t6 .st-toast-icon.svelte-1t011t6{fill:rgb(225, 29, 72);color:#fff}.st-toast.warning.svelte-1t011t6 .st-toast-icon.svelte-1t011t6{fill:rgb(202, 138, 4);color:#fff}.st-toast.dark.svelte-1t011t6.svelte-1t011t6{color:#fff;background:#393939}.st-toast.dark.svelte-1t011t6 .st-toast-close-btn svg.svelte-1t011t6{fill:#fff}.st-toast.dark.svelte-1t011t6 .st-toast-close-btn.svelte-1t011t6:focus{border:solid 1px #fff;border-radius:3px}.st-toast.dark.svelte-1t011t6 .st-toast-close-btn.svelte-1t011t6:focus:focus{border-color:#fff;outline:none}.st-toast.dark.success.svelte-1t011t6 .st-toast-icon.svelte-1t011t6{fill:rgb(22, 163, 74);color:#fff}.st-toast.dark.success.svelte-1t011t6 .st-toast-header.svelte-1t011t6{border-bottom:solid 1px #fff}.st-toast.dark.info.svelte-1t011t6 .st-toast-icon.svelte-1t011t6{fill:rgb(2, 132, 199);color:#fff}.st-toast.dark.info.svelte-1t011t6 .st-toast-header.svelte-1t011t6{border-bottom:solid 1px #fff}.st-toast.dark.error.svelte-1t011t6 .st-toast-icon.svelte-1t011t6{fill:rgb(225, 29, 72);color:#fff}.st-toast.dark.error.svelte-1t011t6 .st-toast-header.svelte-1t011t6{border-bottom:solid 1px #fff}.st-toast.dark.warning.svelte-1t011t6 .st-toast-icon.svelte-1t011t6{fill:rgb(202, 138, 4);color:#fff}.st-toast.dark.warning.svelte-1t011t6 .st-toast-header.svelte-1t011t6{border-bottom:solid 1px #fff}.st-toast.light.svelte-1t011t6.svelte-1t011t6{color:#161616}.st-toast.light.svelte-1t011t6 .st-toast-close-btn svg.svelte-1t011t6{color:#161616}.st-toast.light.svelte-1t011t6 .st-toast-close-btn.svelte-1t011t6:focus{border:solid 1px #fff;border-radius:3px}.st-toast.light.svelte-1t011t6 .st-toast-close-btn.svelte-1t011t6:focus:focus{border-color:#fff;outline:none}.st-toast.light.success.svelte-1t011t6.svelte-1t011t6{border-color:rgb(22, 163, 74);background:rgba(22, 163, 74, 0.2)}.st-toast.light.success.svelte-1t011t6 .st-toast-icon.svelte-1t011t6{fill:rgb(22, 163, 74);color:#fff}.st-toast.light.success.svelte-1t011t6 .st-toast-header.svelte-1t011t6{border-bottom:1px solid rgb(22, 163, 74)}.st-toast.light.info.svelte-1t011t6.svelte-1t011t6{border-color:rgb(2, 132, 199);background:rgba(2, 132, 199, 0.2)}.st-toast.light.info.svelte-1t011t6 .st-toast-icon.svelte-1t011t6{fill:rgb(2, 132, 199);color:#fff}.st-toast.light.info.svelte-1t011t6 .st-toast-header.svelte-1t011t6{border-bottom:1px solid rgb(2, 132, 199)}.st-toast.light.error.svelte-1t011t6.svelte-1t011t6{border-color:rgb(225, 29, 72);background:rgba(225, 29, 72, 0.2)}.st-toast.light.error.svelte-1t011t6 .st-toast-icon.svelte-1t011t6{fill:rgb(225, 29, 72);color:#fff}.st-toast.light.error.svelte-1t011t6 .st-toast-header.svelte-1t011t6{border-bottom:1px solid rgb(225, 29, 72)}.st-toast.light.warning.svelte-1t011t6.svelte-1t011t6{border-color:rgb(202, 138, 4);background:rgba(202, 138, 4, 0.2)}.st-toast.light.warning.svelte-1t011t6 .st-toast-icon.svelte-1t011t6{fill:rgb(202, 138, 4);color:#fff}.st-toast.light.warning.svelte-1t011t6 .st-toast-header.svelte-1t011t6{border-bottom:1px solid rgb(202, 138, 4)}.st-toast-header.svelte-1t011t6.svelte-1t011t6{display:flex;align-items:center;align-items:center;padding:0.5rem 0.75rem;background-clip:padding-box;border-top-left-radius:calc(0.25rem - 1px);border-top-right-radius:calc(0.25rem - 1px)}.st-toast-header.svelte-1t011t6 .st-toast-title.svelte-1t011t6{flex:1;text-align:left;margin-left:0.5rem;outline:none}.st-toast-header.svelte-1t011t6 .st-toast-close-btn.svelte-1t011t6{margin-right:-0.375rem;margin-left:0.75rem;background:transparent;border:0}.st-toast-body.svelte-1t011t6.svelte-1t011t6{position:relative;padding:0.75rem 2rem 0.75rem 2rem;word-wrap:break-word;text-align:left}.st-toast-body.st-toast-no-title.svelte-1t011t6.svelte-1t011t6{padding-left:0.75rem}.st-toast-body.st-toast-no-title.svelte-1t011t6 .st-toast-icon.svelte-1t011t6{display:inline-block;position:relative;top:-1px}.st-toast-body.st-toast-no-title.svelte-1t011t6 .st-toast-description.svelte-1t011t6{margin-left:0.5rem}.st-toast-body.svelte-1t011t6 .st-toast-close-btn.svelte-1t011t6{position:absolute;right:10px;top:13px}.st-toast-body.svelte-1t011t6 .st-toast-close-btn.svelte-1t011t6:focus{border-color:#fff}";
	append(document.head, style);
}

const get_extra_slot_changes$1 = dirty => ({});
const get_extra_slot_context$1 = ctx => ({});
const get_close_icon_slot_changes_1 = dirty => ({});
const get_close_icon_slot_context_1 = ctx => ({});
const get_icon_slot_changes_1 = dirty => ({});
const get_icon_slot_context_1 = ctx => ({});
const get_close_icon_slot_changes$1 = dirty => ({});
const get_close_icon_slot_context$1 = ctx => ({});
const get_icon_slot_changes$1 = dirty => ({});
const get_icon_slot_context$1 = ctx => ({});

// (30:2) {#if data.title}
function create_if_block_5(ctx) {
	let div;
	let t0;
	let strong;
	let t1_value = /*data*/ ctx[1].title + "";
	let t1;
	let t2;
	let button;
	let current;
	let mounted;
	let dispose;
	const icon_slot_template = /*#slots*/ ctx[5].icon;
	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[4], get_icon_slot_context$1);
	const icon_slot_or_fallback = icon_slot || fallback_block_3(ctx);
	const close_icon_slot_template = /*#slots*/ ctx[5]["close-icon"];
	const close_icon_slot = create_slot(close_icon_slot_template, ctx, /*$$scope*/ ctx[4], get_close_icon_slot_context$1);
	const close_icon_slot_or_fallback = close_icon_slot || fallback_block_2();

	return {
		c() {
			div = element("div");
			if (icon_slot_or_fallback) icon_slot_or_fallback.c();
			t0 = space();
			strong = element("strong");
			t1 = text(t1_value);
			t2 = space();
			button = element("button");
			if (close_icon_slot_or_fallback) close_icon_slot_or_fallback.c();
			attr(strong, "class", "st-toast-title svelte-1t011t6");
			attr(button, "data-notification-btn", "");
			attr(button, "class", "st-toast-close-btn svelte-1t011t6");
			attr(button, "type", "button");
			attr(button, "aria-label", "close");
			attr(div, "class", "st-toast-header svelte-1t011t6");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (icon_slot_or_fallback) {
				icon_slot_or_fallback.m(div, null);
			}

			append(div, t0);
			append(div, strong);
			append(strong, t1);
			append(div, t2);
			append(div, button);

			if (close_icon_slot_or_fallback) {
				close_icon_slot_or_fallback.m(button, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*onRemove*/ ctx[2]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (icon_slot) {
				if (icon_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(icon_slot, icon_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_icon_slot_changes$1, get_icon_slot_context$1);
				}
			} else {
				if (icon_slot_or_fallback && icon_slot_or_fallback.p && dirty & /*data*/ 2) {
					icon_slot_or_fallback.p(ctx, dirty);
				}
			}

			if ((!current || dirty & /*data*/ 2) && t1_value !== (t1_value = /*data*/ ctx[1].title + "")) set_data(t1, t1_value);

			if (close_icon_slot) {
				if (close_icon_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(close_icon_slot, close_icon_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_close_icon_slot_changes$1, get_close_icon_slot_context$1);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(icon_slot_or_fallback, local);
			transition_in(close_icon_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(icon_slot_or_fallback, local);
			transition_out(close_icon_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
			if (close_icon_slot_or_fallback) close_icon_slot_or_fallback.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

// (80:8) {:else}
function create_else_block_1(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1\ts1,0.4,1,1S10.6,16,10,16z");
			attr(path1, "d", "M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S10.6,16,10,16z");
			attr(path1, "data-icon-path", "inner-path");
			attr(path1, "opacity", "0");
			attr(svg, "class", "st-toast-icon svelte-1t011t6");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (64:40) 
function create_if_block_8(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z");
			attr(path1, "d", "M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z");
			attr(path1, "data-icon-path", "inner-path");
			attr(path1, "opacity", "0");
			attr(svg, "class", "st-toast-icon svelte-1t011t6");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (52:39) 
function create_if_block_7(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,7Zm4,17.12H12V21.88h2.88V15.12H13V12.88h4.13v9H20Z");
			attr(svg, "class", "st-toast-icon svelte-1t011t6");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 32 32");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (33:8) {#if data.type === 'success'}
function create_if_block_6(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M10,1c-4.9,0-9,4.1-9,9s4.1,9,9,9s9-4,9-9S15,1,10,1z M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z");
			attr(path1, "fill", "none");
			attr(path1, "d", "M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z");
			attr(path1, "data-icon-path", "inner-path");
			attr(path1, "opacity", "0");
			attr(svg, "class", "st-toast-icon svelte-1t011t6");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (32:24)          
function fallback_block_3(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*data*/ ctx[1].type === "success") return create_if_block_6;
		if (/*data*/ ctx[1].type === "info") return create_if_block_7;
		if (/*data*/ ctx[1].type === "error") return create_if_block_8;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (107:32)            
function fallback_block_2(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "bx--toast-notification__close-icon svelte-1t011t6");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 32 32");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (125:4) {#if !data.title}
function create_if_block_1$1(ctx) {
	let current;
	const icon_slot_template = /*#slots*/ ctx[5].icon;
	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[4], get_icon_slot_context_1);
	const icon_slot_or_fallback = icon_slot || fallback_block_1$1(ctx);

	return {
		c() {
			if (icon_slot_or_fallback) icon_slot_or_fallback.c();
		},
		m(target, anchor) {
			if (icon_slot_or_fallback) {
				icon_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (icon_slot) {
				if (icon_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(icon_slot, icon_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_icon_slot_changes_1, get_icon_slot_context_1);
				}
			} else {
				if (icon_slot_or_fallback && icon_slot_or_fallback.p && dirty & /*data*/ 2) {
					icon_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(icon_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(icon_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
		}
	};
}

// (174:8) {:else}
function create_else_block$1(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1\ts1,0.4,1,1S10.6,16,10,16z");
			attr(path1, "d", "M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S10.6,16,10,16z");
			attr(path1, "data-icon-path", "inner-path");
			attr(path1, "opacity", "0");
			attr(svg, "class", "st-toast-icon svelte-1t011t6");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (158:40) 
function create_if_block_4$1(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z");
			attr(path1, "d", "M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z");
			attr(path1, "data-icon-path", "inner-path");
			attr(path1, "opacity", "0");
			attr(svg, "class", "st-toast-icon svelte-1t011t6");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (146:39) 
function create_if_block_3$1(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,7Zm4,17.12H12V21.88h2.88V15.12H13V12.88h4.13v9H20Z");
			attr(svg, "class", "st-toast-icon svelte-1t011t6");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 32 32");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (127:8) {#if data.type === 'success'}
function create_if_block_2$1(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M10,1c-4.9,0-9,4.1-9,9s4.1,9,9,9s9-4,9-9S15,1,10,1z M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z");
			attr(path1, "fill", "none");
			attr(path1, "d", "M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z");
			attr(path1, "data-icon-path", "inner-path");
			attr(path1, "opacity", "0");
			attr(svg, "class", "st-toast-icon svelte-1t011t6");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (126:24)          
function fallback_block_1$1(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*data*/ ctx[1].type === "success") return create_if_block_2$1;
		if (/*data*/ ctx[1].type === "info") return create_if_block_3$1;
		if (/*data*/ ctx[1].type === "error") return create_if_block_4$1;
		return create_else_block$1;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (194:4) {#if !data.title}
function create_if_block$1(ctx) {
	let button;
	let current;
	let mounted;
	let dispose;
	const close_icon_slot_template = /*#slots*/ ctx[5]["close-icon"];
	const close_icon_slot = create_slot(close_icon_slot_template, ctx, /*$$scope*/ ctx[4], get_close_icon_slot_context_1);
	const close_icon_slot_or_fallback = close_icon_slot || fallback_block$1();

	return {
		c() {
			button = element("button");
			if (close_icon_slot_or_fallback) close_icon_slot_or_fallback.c();
			attr(button, "data-notification-btn", "");
			attr(button, "class", "st-toast-close-btn svelte-1t011t6");
			attr(button, "type", "button");
			attr(button, "aria-label", "close");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (close_icon_slot_or_fallback) {
				close_icon_slot_or_fallback.m(button, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*onRemove*/ ctx[2]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (close_icon_slot) {
				if (close_icon_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(close_icon_slot, close_icon_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_close_icon_slot_changes_1, get_close_icon_slot_context_1);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(close_icon_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(close_icon_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			if (close_icon_slot_or_fallback) close_icon_slot_or_fallback.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

// (202:32)            
function fallback_block$1(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "bx--toast-notification__close-icon svelte-1t011t6");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 32 32");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function create_fragment$1(ctx) {
	let div2;
	let t0;
	let div1;
	let t1;
	let span;
	let t2_value = /*data*/ ctx[1].description + "";
	let t2;
	let t3;
	let t4;
	let div0;
	let div2_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*data*/ ctx[1].title && create_if_block_5(ctx);
	let if_block1 = !/*data*/ ctx[1].title && create_if_block_1$1(ctx);
	let if_block2 = !/*data*/ ctx[1].title && create_if_block$1(ctx);
	const extra_slot_template = /*#slots*/ ctx[5].extra;
	const extra_slot = create_slot(extra_slot_template, ctx, /*$$scope*/ ctx[4], get_extra_slot_context$1);

	return {
		c() {
			div2 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div1 = element("div");
			if (if_block1) if_block1.c();
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			div0 = element("div");
			if (extra_slot) extra_slot.c();
			attr(span, "class", "st-toast-description svelte-1t011t6");
			attr(div0, "class", "st-toast-extra");
			attr(div1, "class", "st-toast-body svelte-1t011t6");
			toggle_class(div1, "st-toast-no-title", !/*data*/ ctx[1].title);
			attr(div2, "class", div2_class_value = "st-toast bootstrap " + (/*data*/ ctx[1].theme || /*theme*/ ctx[0]) + " " + (/*data*/ ctx[1].type || "info") + " svelte-1t011t6");
			attr(div2, "role", "alert");
			attr(div2, "aria-live", "assertive");
			attr(div2, "aria-atomic", "true");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			if (if_block0) if_block0.m(div2, null);
			append(div2, t0);
			append(div2, div1);
			if (if_block1) if_block1.m(div1, null);
			append(div1, t1);
			append(div1, span);
			append(span, t2);
			append(div1, t3);
			if (if_block2) if_block2.m(div1, null);
			append(div1, t4);
			append(div1, div0);

			if (extra_slot) {
				extra_slot.m(div0, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div2, "click", /*onClick*/ ctx[3]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*data*/ ctx[1].title) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*data*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_5(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div2, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!/*data*/ ctx[1].title) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*data*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if ((!current || dirty & /*data*/ 2) && t2_value !== (t2_value = /*data*/ ctx[1].description + "")) set_data(t2, t2_value);

			if (!/*data*/ ctx[1].title) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*data*/ 2) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block$1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, t4);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (extra_slot) {
				if (extra_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(extra_slot, extra_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_extra_slot_changes$1, get_extra_slot_context$1);
				}
			}

			if (dirty & /*data*/ 2) {
				toggle_class(div1, "st-toast-no-title", !/*data*/ ctx[1].title);
			}

			if (!current || dirty & /*data, theme*/ 3 && div2_class_value !== (div2_class_value = "st-toast bootstrap " + (/*data*/ ctx[1].theme || /*theme*/ ctx[0]) + " " + (/*data*/ ctx[1].type || "info") + " svelte-1t011t6")) {
				attr(div2, "class", div2_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(extra_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(extra_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (extra_slot) extra_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { theme = "light" } = $$props;
	let { data = {} } = $$props;

	const onRemove = e => {
		e.stopPropagation();
		data.remove();
		if (typeof data.onRemove === "function") data.onRemove();
	};

	const onClick = () => {
		if (typeof data.onClick === "function") data.onClick();
	};

	$$self.$$set = $$props => {
		if ("theme" in $$props) $$invalidate(0, theme = $$props.theme);
		if ("data" in $$props) $$invalidate(1, data = $$props.data);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	return [theme, data, onRemove, onClick, $$scope, slots];
}

class BootstrapToast extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1t011t6-style")) add_css$1();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { theme: 0, data: 1 });
	}
}

function is_date(obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
}

function get_interpolator(a, b) {
    if (a === b || a !== a)
        return () => a;
    const type = typeof a;
    if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
        throw new Error('Cannot interpolate values of different type');
    }
    if (Array.isArray(a)) {
        const arr = b.map((bi, i) => {
            return get_interpolator(a[i], bi);
        });
        return t => arr.map(fn => fn(t));
    }
    if (type === 'object') {
        if (!a || !b)
            throw new Error('Object cannot be null');
        if (is_date(a) && is_date(b)) {
            a = a.getTime();
            b = b.getTime();
            const delta = b - a;
            return t => new Date(a + t * delta);
        }
        const keys = Object.keys(b);
        const interpolators = {};
        keys.forEach(key => {
            interpolators[key] = get_interpolator(a[key], b[key]);
        });
        return t => {
            const result = {};
            keys.forEach(key => {
                result[key] = interpolators[key](t);
            });
            return result;
        };
    }
    if (type === 'number') {
        const delta = b - a;
        return t => a + t * delta;
    }
    throw new Error(`Cannot interpolate ${type} values`);
}
function tweened(value, defaults = {}) {
    const store = writable(value);
    let task;
    let target_value = value;
    function set(new_value, opts) {
        if (value == null) {
            store.set(value = new_value);
            return Promise.resolve();
        }
        target_value = new_value;
        let previous_task = task;
        let started = false;
        let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
        if (duration === 0) {
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            store.set(value = target_value);
            return Promise.resolve();
        }
        const start = now() + delay;
        let fn;
        task = loop(now => {
            if (now < start)
                return true;
            if (!started) {
                fn = interpolate(value, new_value);
                if (typeof duration === 'function')
                    duration = duration(value, new_value);
                started = true;
            }
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            const elapsed = now - start;
            if (elapsed > duration) {
                store.set(value = new_value);
                return false;
            }
            // @ts-ignore
            store.set(value = fn(easing(elapsed / duration)));
            return true;
        });
        return task.promise;
    }
    return {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe
    };
}

/* src/FlatToast.svelte generated by Svelte v3.35.0 */

function add_css() {
	var style = element("style");
	style.id = "svelte-is9c7e-style";
	style.textContent = ".st-toast.svelte-is9c7e.svelte-is9c7e{display:flex;pointer-events:auto;width:320px;height:auto;padding-left:0.875rem;color:#fff;box-shadow:0 2px 6px 0 rgba(0, 0, 0, 0.2);position:relative;cursor:pointer}.st-toast.svelte-is9c7e .st-toast-icon.svelte-is9c7e{flex-shrink:0;margin-right:0.875rem;margin-top:0.875rem}.st-toast.svelte-is9c7e progress[value].svelte-is9c7e{appearance:none;display:block;width:100%;position:absolute;bottom:0;left:0;right:0;height:4px}.st-toast.dark.svelte-is9c7e.svelte-is9c7e{color:#fff;background:#393939}.st-toast.dark.svelte-is9c7e progress[value].svelte-is9c7e::-webkit-progress-bar{background-color:#393939}.st-toast.dark.svelte-is9c7e .st-toast-close-btn svg.svelte-is9c7e{fill:#fff}.st-toast.dark.svelte-is9c7e .st-toast-close-btn.svelte-is9c7e:focus{border:solid 1px #fff}.st-toast.dark.success.svelte-is9c7e.svelte-is9c7e{border-left:3px solid rgb(22, 163, 74)}.st-toast.dark.success.svelte-is9c7e .st-toast-icon.svelte-is9c7e{fill:rgb(22, 163, 74);color:#fff}.st-toast.dark.success.svelte-is9c7e progress[value].svelte-is9c7e::-webkit-progress-value{background-color:rgb(22, 163, 74)}.st-toast.dark.info.svelte-is9c7e.svelte-is9c7e{border-left:3px solid rgb(2, 132, 199)}.st-toast.dark.info.svelte-is9c7e .st-toast-icon.svelte-is9c7e{fill:rgb(2, 132, 199);color:#fff}.st-toast.dark.info.svelte-is9c7e progress[value].svelte-is9c7e::-webkit-progress-value{background-color:rgb(2, 132, 199)}.st-toast.dark.error.svelte-is9c7e.svelte-is9c7e{border-left:3px solid rgb(225, 29, 72)}.st-toast.dark.error.svelte-is9c7e .st-toast-icon.svelte-is9c7e{fill:rgb(225, 29, 72);color:#fff}.st-toast.dark.error.svelte-is9c7e progress[value].svelte-is9c7e::-webkit-progress-value{background-color:rgb(225, 29, 72)}.st-toast.dark.warning.svelte-is9c7e.svelte-is9c7e{border-left:3px solid rgb(202, 138, 4)}.st-toast.dark.warning.svelte-is9c7e .st-toast-icon.svelte-is9c7e{fill:rgb(202, 138, 4);color:#fff}.st-toast.dark.warning.svelte-is9c7e progress[value].svelte-is9c7e::-webkit-progress-value{background-color:rgb(202, 138, 4)}.st-toast.light.svelte-is9c7e.svelte-is9c7e{color:#161616;fill:#161616}.st-toast.light.success.svelte-is9c7e.svelte-is9c7e{border-left:3px solid rgb(22, 163, 74);background:rgba(22, 163, 74, 0.2)}.st-toast.light.success.svelte-is9c7e progress.svelte-is9c7e{background:rgba(22, 163, 74, 0.2)}.st-toast.light.success.svelte-is9c7e progress[value].svelte-is9c7e::-webkit-progress-bar{background-color:transparent}.st-toast.light.success.svelte-is9c7e progress[value].svelte-is9c7e::-webkit-progress-value{background-color:rgb(22, 163, 74)}.st-toast.light.success.svelte-is9c7e .st-toast-icon.svelte-is9c7e{fill:rgb(22, 163, 74)}.st-toast.light.success.svelte-is9c7e .st-toast-close-btn.svelte-is9c7e:focus{border:solid 1px rgb(22, 163, 74)}.st-toast.light.success.svelte-is9c7e.svelte-is9c7e::before{border-color:rgb(22, 163, 74);content:'';pointer-events:none;position:absolute;top:0;left:0;width:100%;height:100%;box-sizing:border-box;filter:opacity(0.4);border-style:solid;border-width:1px 1px 1px 0}.st-toast.light.info.svelte-is9c7e.svelte-is9c7e{border-left:3px solid rgb(2, 132, 199);background:rgba(2, 132, 199, 0.2)}.st-toast.light.info.svelte-is9c7e progress.svelte-is9c7e{background:rgba(2, 132, 199, 0.2)}.st-toast.light.info.svelte-is9c7e progress[value].svelte-is9c7e::-webkit-progress-bar{background-color:transparent}.st-toast.light.info.svelte-is9c7e progress[value].svelte-is9c7e::-webkit-progress-value{background-color:rgb(2, 132, 199)}.st-toast.light.info.svelte-is9c7e .st-toast-icon.svelte-is9c7e{fill:rgb(2, 132, 199)}.st-toast.light.info.svelte-is9c7e .st-toast-close-btn.svelte-is9c7e:focus{border:solid 1px rgb(2, 132, 199)}.st-toast.light.info.svelte-is9c7e.svelte-is9c7e::before{border-color:rgb(2, 132, 199);content:'';pointer-events:none;position:absolute;top:0;left:0;width:100%;height:100%;box-sizing:border-box;filter:opacity(0.4);border-style:solid;border-width:1px 1px 1px 0}.st-toast.light.error.svelte-is9c7e.svelte-is9c7e{border-left:3px solid rgb(225, 29, 72);background:rgba(225, 29, 72, 0.2)}.st-toast.light.error.svelte-is9c7e progress.svelte-is9c7e{background:rgba(225, 29, 72, 0.2)}.st-toast.light.error.svelte-is9c7e progress[value].svelte-is9c7e::-webkit-progress-bar{background-color:transparent}.st-toast.light.error.svelte-is9c7e progress[value].svelte-is9c7e::-webkit-progress-value{background-color:rgb(225, 29, 72)}.st-toast.light.error.svelte-is9c7e .st-toast-icon.svelte-is9c7e{fill:rgb(225, 29, 72)}.st-toast.light.error.svelte-is9c7e .st-toast-close-btn.svelte-is9c7e:focus{border:solid 1px rgb(225, 29, 72)}.st-toast.light.error.svelte-is9c7e.svelte-is9c7e::before{border-color:rgb(225, 29, 72);content:'';pointer-events:none;position:absolute;top:0;left:0;width:100%;height:100%;box-sizing:border-box;filter:opacity(0.4);border-style:solid;border-width:1px 1px 1px 0}.st-toast.light.warning.svelte-is9c7e.svelte-is9c7e{border-left:3px solid rgb(202, 138, 4);background:rgba(202, 138, 4, 0.2)}.st-toast.light.warning.svelte-is9c7e progress.svelte-is9c7e{background:rgba(202, 138, 4, 0.2)}.st-toast.light.warning.svelte-is9c7e progress[value].svelte-is9c7e::-webkit-progress-bar{background-color:transparent}.st-toast.light.warning.svelte-is9c7e progress[value].svelte-is9c7e::-webkit-progress-value{background-color:rgb(202, 138, 4)}.st-toast.light.warning.svelte-is9c7e .st-toast-icon.svelte-is9c7e{fill:rgb(202, 138, 4)}.st-toast.light.warning.svelte-is9c7e .st-toast-close-btn.svelte-is9c7e:focus{border:solid 1px rgb(202, 138, 4)}.st-toast.light.warning.svelte-is9c7e.svelte-is9c7e::before{border-color:rgb(202, 138, 4);content:'';pointer-events:none;position:absolute;top:0;left:0;width:100%;height:100%;box-sizing:border-box;filter:opacity(0.4);border-style:solid;border-width:1px 1px 1px 0}.st-toast-details.svelte-is9c7e.svelte-is9c7e{margin-top:0.875rem;margin-right:1rem;text-align:left;align-self:flex-start}.st-toast-details.svelte-is9c7e .st-toast-title.svelte-is9c7e{font-size:0.875rem;font-weight:600;line-height:1.125rem;letter-spacing:0.16px;font-weight:600;word-break:break-word;margin:0;outline:none}.st-toast-details.svelte-is9c7e .st-toast-description.svelte-is9c7e{font-size:0.875rem;font-weight:400;line-height:1.125rem;letter-spacing:0.16px;margin-top:0;margin-bottom:1rem;word-break:break-word}.st-toast-close-btn.svelte-is9c7e.svelte-is9c7e{outline:2px solid transparent;outline-offset:-2px;display:flex;align-items:center;justify-content:center;background-color:transparent;border:none;cursor:pointer;margin-left:auto;padding:0;height:3rem;width:3rem;min-height:3rem;min-width:3rem;transition:outline 110ms, background-color 110ms}";
	append(document.head, style);
}

const get_close_icon_slot_changes = dirty => ({});
const get_close_icon_slot_context = ctx => ({});
const get_extra_slot_changes = dirty => ({});
const get_extra_slot_context = ctx => ({});
const get_icon_slot_changes = dirty => ({});
const get_icon_slot_context = ctx => ({});

// (92:4) {:else}
function create_else_block(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1\ts1,0.4,1,1S10.6,16,10,16z");
			attr(path1, "d", "M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S10.6,16,10,16z");
			attr(path1, "data-icon-path", "inner-path");
			attr(path1, "opacity", "0");
			attr(svg, "class", "st-toast-icon svelte-is9c7e");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (76:36) 
function create_if_block_4(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z");
			attr(path1, "d", "M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z");
			attr(path1, "data-icon-path", "inner-path");
			attr(path1, "opacity", "0");
			attr(svg, "class", "st-toast-icon svelte-is9c7e");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (64:35) 
function create_if_block_3(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,7Zm4,17.12H12V21.88h2.88V15.12H13V12.88h4.13v9H20Z");
			attr(svg, "class", "st-toast-icon svelte-is9c7e");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 32 32");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (45:4) {#if data.type === 'success'}
function create_if_block_2(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M10,1c-4.9,0-9,4.1-9,9s4.1,9,9,9s9-4,9-9S15,1,10,1z M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z");
			attr(path1, "fill", "none");
			attr(path1, "d", "M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z");
			attr(path1, "data-icon-path", "inner-path");
			attr(path1, "opacity", "0");
			attr(svg, "class", "st-toast-icon svelte-is9c7e");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (44:20)      
function fallback_block_1(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*data*/ ctx[1].type === "success") return create_if_block_2;
		if (/*data*/ ctx[1].type === "info") return create_if_block_3;
		if (/*data*/ ctx[1].type === "error") return create_if_block_4;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (112:4) {#if data.title}
function create_if_block_1(ctx) {
	let h3;
	let t_value = /*data*/ ctx[1].title + "";
	let t;

	return {
		c() {
			h3 = element("h3");
			t = text(t_value);
			attr(h3, "class", "st-toast-title svelte-is9c7e");
		},
		m(target, anchor) {
			insert(target, h3, anchor);
			append(h3, t);
		},
		p(ctx, dirty) {
			if (dirty & /*data*/ 2 && t_value !== (t_value = /*data*/ ctx[1].title + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(h3);
		}
	};
}

// (127:28)        
function fallback_block(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "bx--toast-notification__close-icon svelte-is9c7e");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 32 32");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (142:2) {#if data.showProgress}
function create_if_block(ctx) {
	let progress_1;

	return {
		c() {
			progress_1 = element("progress");
			set_style(progress_1, "height", /*data*/ ctx[1].duration > 0 ? "4px" : 0);
			progress_1.value = /*$progress*/ ctx[2];
			attr(progress_1, "class", "svelte-is9c7e");
		},
		m(target, anchor) {
			insert(target, progress_1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*data*/ 2) {
				set_style(progress_1, "height", /*data*/ ctx[1].duration > 0 ? "4px" : 0);
			}

			if (dirty & /*$progress*/ 4) {
				progress_1.value = /*$progress*/ ctx[2];
			}
		},
		d(detaching) {
			if (detaching) detach(progress_1);
		}
	};
}

function create_fragment(ctx) {
	let div2;
	let t0;
	let div1;
	let t1;
	let p;
	let t2_value = /*data*/ ctx[1].description + "";
	let t2;
	let t3;
	let div0;
	let t4;
	let button;
	let t5;
	let div2_class_value;
	let current;
	let mounted;
	let dispose;
	const icon_slot_template = /*#slots*/ ctx[7].icon;
	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[6], get_icon_slot_context);
	const icon_slot_or_fallback = icon_slot || fallback_block_1(ctx);
	let if_block0 = /*data*/ ctx[1].title && create_if_block_1(ctx);
	const extra_slot_template = /*#slots*/ ctx[7].extra;
	const extra_slot = create_slot(extra_slot_template, ctx, /*$$scope*/ ctx[6], get_extra_slot_context);
	const close_icon_slot_template = /*#slots*/ ctx[7]["close-icon"];
	const close_icon_slot = create_slot(close_icon_slot_template, ctx, /*$$scope*/ ctx[6], get_close_icon_slot_context);
	const close_icon_slot_or_fallback = close_icon_slot || fallback_block();
	let if_block1 = /*data*/ ctx[1].showProgress && create_if_block(ctx);

	return {
		c() {
			div2 = element("div");
			if (icon_slot_or_fallback) icon_slot_or_fallback.c();
			t0 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			p = element("p");
			t2 = text(t2_value);
			t3 = space();
			div0 = element("div");
			if (extra_slot) extra_slot.c();
			t4 = space();
			button = element("button");
			if (close_icon_slot_or_fallback) close_icon_slot_or_fallback.c();
			t5 = space();
			if (if_block1) if_block1.c();
			attr(p, "class", "st-toast-description svelte-is9c7e");
			attr(div0, "class", "st-toast-extra");
			attr(div1, "class", "st-toast-details svelte-is9c7e");
			attr(button, "class", "st-toast-close-btn svelte-is9c7e");
			attr(button, "type", "button");
			attr(button, "aria-label", "close");
			attr(div2, "class", div2_class_value = "st-toast flat " + (/*data*/ ctx[1].theme || /*theme*/ ctx[0]) + " " + (/*data*/ ctx[1].type || "info") + " svelte-is9c7e");
			attr(div2, "role", "alert");
			attr(div2, "aria-live", "assertive");
			attr(div2, "aria-atomic", "true");
		},
		m(target, anchor) {
			insert(target, div2, anchor);

			if (icon_slot_or_fallback) {
				icon_slot_or_fallback.m(div2, null);
			}

			append(div2, t0);
			append(div2, div1);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t1);
			append(div1, p);
			append(p, t2);
			append(div1, t3);
			append(div1, div0);

			if (extra_slot) {
				extra_slot.m(div0, null);
			}

			append(div2, t4);
			append(div2, button);

			if (close_icon_slot_or_fallback) {
				close_icon_slot_or_fallback.m(button, null);
			}

			append(div2, t5);
			if (if_block1) if_block1.m(div2, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button, "click", /*onRemove*/ ctx[4]),
					listen(div2, "click", /*onClick*/ ctx[5])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (icon_slot) {
				if (icon_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(icon_slot, icon_slot_template, ctx, /*$$scope*/ ctx[6], dirty, get_icon_slot_changes, get_icon_slot_context);
				}
			} else {
				if (icon_slot_or_fallback && icon_slot_or_fallback.p && dirty & /*data*/ 2) {
					icon_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (/*data*/ ctx[1].title) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if ((!current || dirty & /*data*/ 2) && t2_value !== (t2_value = /*data*/ ctx[1].description + "")) set_data(t2, t2_value);

			if (extra_slot) {
				if (extra_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(extra_slot, extra_slot_template, ctx, /*$$scope*/ ctx[6], dirty, get_extra_slot_changes, get_extra_slot_context);
				}
			}

			if (close_icon_slot) {
				if (close_icon_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(close_icon_slot, close_icon_slot_template, ctx, /*$$scope*/ ctx[6], dirty, get_close_icon_slot_changes, get_close_icon_slot_context);
				}
			}

			if (/*data*/ ctx[1].showProgress) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(div2, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty & /*data, theme*/ 3 && div2_class_value !== (div2_class_value = "st-toast flat " + (/*data*/ ctx[1].theme || /*theme*/ ctx[0]) + " " + (/*data*/ ctx[1].type || "info") + " svelte-is9c7e")) {
				attr(div2, "class", div2_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(icon_slot_or_fallback, local);
			transition_in(extra_slot, local);
			transition_in(close_icon_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(icon_slot_or_fallback, local);
			transition_out(extra_slot, local);
			transition_out(close_icon_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
			if (if_block0) if_block0.d();
			if (extra_slot) extra_slot.d(detaching);
			if (close_icon_slot_or_fallback) close_icon_slot_or_fallback.d(detaching);
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $progress;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { theme = "light" } = $$props;
	let { data = {} } = $$props;
	const progress = tweened(1, { duration: data.duration, easing: identity });
	component_subscribe($$self, progress, value => $$invalidate(2, $progress = value));

	onMount(() => {
		progress.set(0, { duration: data.duration });
	});

	const onRemove = e => {
		e.stopPropagation();
		data.remove();
		if (typeof data.onRemove === "function") data.onRemove();
	};

	const onClick = () => {
		if (typeof data.onClick === "function") data.onClick();
	};

	$$self.$$set = $$props => {
		if ("theme" in $$props) $$invalidate(0, theme = $$props.theme);
		if ("data" in $$props) $$invalidate(1, data = $$props.data);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	return [theme, data, $progress, progress, onRemove, onClick, $$scope, slots];
}

class FlatToast extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-is9c7e-style")) add_css();
		init(this, options, instance, create_fragment, safe_not_equal, { theme: 0, data: 1 });
	}
}

export { BootstrapToast, FlatToast, ToastContainer, toasts };
